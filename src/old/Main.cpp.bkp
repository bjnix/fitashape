#include <osgViewer/Viewer>
#include <osg/ShapeDrawable>
#include <osg/PolygonMode>
#include <osg/StateSet>
#include <osgDB/ReadFile> 
#include <osgGA/GUIEventHandler>
#include <osg/PositionAttitudeTransform>
#include <osg/Texture2D>
#include <osgGA/NodeTrackerManipulator>
#include <osgParticle/PrecipitationEffect>
#include <osg/Camera>
#include <osgGA/TrackballManipulator>
#include <osg/Quat>
#include <osg/Light>
//#include <osgViewer/ViewerEventHandlers>
//#include <osgGA/StateSetManipulator>

#include <fstream> // For output logging
#include <iostream>
#include <cstdio>
#include <math.h>

#include <sys/select.h>

#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

#include "InputClient.hpp"

#define _USE_MATH_DEFINES
using namespace std;

osg::PositionAttitudeTransform* sphereXForm = NULL;
osg::ref_ptr<osg::Node> cycle = NULL;
osg::ref_ptr<osg::Camera> myCam = new osg::Camera;
osg::ref_ptr<osg::LightSource> ls = new osg::LightSource;
double rot = 0.0;

/**
 * Update the game state based on present inputs.
 * This is on a timer loop independent of frame updates, so that input
 * happens at a consistent rate.
 */
void gameLoop(struct Keys* keys) {

 	if(keys->up) {
		sphereXForm->setPosition(osg::Vec3(1.0 * cos(rot),0, 1.0 * sin(rot)) + sphereXForm->getPosition());			
	}

	if(keys->down) {
		sphereXForm->setPosition(sphereXForm->getPosition() - osg::Vec3(1.0 * cos(rot),0, 1.0 * sin(rot)));
	}

	if(keys->right) {
		rot = rot + M_PI/36.0;
		sphereXForm->setAttitude(osg::Quat(M_PI, osg::Vec3d(1.0,0.0,0.0), rot,osg::Vec3d(0.0,-1.0,0.0), 0.0, osg::Vec3d(0.0,0.0,0.0)));
	}

	if(keys->left) {
		rot = rot - M_PI/36.0;
		sphereXForm->setAttitude(osg::Quat(M_PI, osg::Vec3d(1.0,0.0,0.0), rot,osg::Vec3d(0.0,-1.0,0.0), 0.0, osg::Vec3d(0.0,0.0,0.0)));
	}

	// Regardless of what happened, fix the camera
	myCam->setViewMatrixAsLookAt(
			sphereXForm->getPosition() + osg::Vec3(-7.5 * cos(rot), 7.5, -7.5 * sin(rot)), // eye above xy-plane
			sphereXForm->getPosition() + osg::Vec3(0, 3, 0),    // gaze at cycle
			osg::Vec3(0, 1, 0));   // usual up vector
}

int main(int argc, char **argv) {


	//Figure out arguments
	char fname[25];
	sprintf(fname, "log_%d.txt", rand());
	ofstream log_file(fname, std::ios_base::out | std::ios_base::app );
	log_file << (argc-1) << " real arguments:";
	for(int i=1; i<argc; i++) {
		log_file << " " << argv[i];
	}
	log_file << endl;

	//Creating the viewer	
    osgViewer::Viewer viewer;

	//Creating the root node
	osg::ref_ptr<osg::Group> root (new osg::Group);

	//The geode containing our shpae
   	osg::ref_ptr<osg::Geode> myshapegeode (new osg::Geode);
	
	//Our shape: a capsule, it could have been any other geometry (a box, plane, cylinder etc.)
	osg::ref_ptr<osg::Box> myCapsule (new osg::Box(osg::Vec3f(0,0,0), 1.0f));

	osg::Vec2Array* texcoords = new osg::Vec2Array(4);
		    	(*texcoords)[0].set(0.0f,1.0f);
			(*texcoords)[1].set(0.0f,0.0f);
	        	(*texcoords)[2].set(1.0f,0.0f);
	 	        (*texcoords)[3].set(1.0f,1.0f);
	osg::Vec3Array* normals = new osg::Vec3Array(1);
			(*normals)[0].set(0.0f,1.0f,0.0f);
	osg::Vec4Array* colors = new osg::Vec4Array(1);
		    	(*colors)[0].set(1.0f,1.0f,1.0f,1.0f);
	int x = -100;
	bool tog = true;
	for(x = -100; x <= 100; x = x + 5) { 
		int y = -100;
		for(y = -100; y <= 100; y = y + 5) {
			osg::ref_ptr<osg::Geometry> myPlane (new osg::Geometry());
	
			//plane verticies
			osg::Vec3Array* pyramidVertices = new osg::Vec3Array;
			pyramidVertices->push_back( osg::Vec3( x, 0, y) ); // front left
			pyramidVertices->push_back( osg::Vec3( x, 0, y + 5) ); // front right
			pyramidVertices->push_back( osg::Vec3( x + 5, 0, y + 5) ); // back right 
			pyramidVertices->push_back( osg::Vec3( x + 5, 0, y) ); // front left
			pyramidVertices->push_back( osg::Vec3( x, 0, y) ); // front left
			myPlane->setVertexArray(pyramidVertices);
	
	 	 	myPlane->setTexCoordArray(0,texcoords);
			
		        myPlane->setNormalArray(normals);
		    	myPlane->setNormalBinding(osg::Geometry::BIND_OVERALL);
			
		    	myPlane->setColorArray(colors);
    			myPlane->setColorBinding(osg::Geometry::BIND_OVERALL);
	
    			myPlane->addPrimitiveSet(new osg::DrawArrays(GL_QUADS,0,4));
			myshapegeode->addDrawable(myPlane);

			tog = !tog;
		}
	}

	//texture
	osg::Texture2D* KLN89FaceTexture = new osg::Texture2D;

	// protect from being optimized away as static state:
	KLN89FaceTexture->setDataVariance(osg::Object::DYNAMIC); 

	// load an image by reading a file: 
	osg::Image* klnFace = osgDB::readImageFile("./assets/TronBackground.jpg");
	//osg::Image* klnFace = osgDB::readImageFile("/home/nplanam/CyberCycles/assets/TronBackground.jpg");
	if (!klnFace) {
		cout << " couldn't find texture, quiting." << endl;
		return -1;
	}

   	// Assign the texture to the image we read from file: 
  	 KLN89FaceTexture->setImage(klnFace);
	// Create a new StateSet with default settings: 
	osg::StateSet* stateOne = new osg::StateSet();

	// Assign texture unit 0 of our new StateSet to the texture 
	// we just created and enable the texture.
	stateOne->setTextureAttributeAndModes
	(0,KLN89FaceTexture,osg::StateAttribute::ON);
	// Associate this state set with the Geode that contains
	// the pyramid: 
	myshapegeode->setStateSet(stateOne);

	//Our shape drawable
	osg::ref_ptr<osg::ShapeDrawable> capsuledrawable (new osg::ShapeDrawable(myCapsule.get()));
	
	//myshapegeode->addDrawable(capsuledrawable.get());

	root->addChild(myshapegeode.get());
	
	//model loading test
	sphereXForm = new osg::PositionAttitudeTransform();
	sphereXForm->setPosition(osg::Vec3(0,0,0));
	sphereXForm->setAttitude(osg::Quat(M_PI, osg::Vec3(1,0,0)));
	cycle = osgDB::readNodeFile("./assets/Light Cycle/HQ_Movie cycle.obj");
	//cycle = osgDB::readNodeFile("/home/nplanam/CyberCycles/assets/Light Cycle/HQ_Movie cycle.obj");
	root->addChild(sphereXForm);
	sphereXForm->addChild(cycle);

	myCam->setClearColor(osg::Vec4(0, 0, 255, 1)); // black background
 	// set dimensions of the view volume
	myCam->setProjectionMatrixAsPerspective(30, 4.0 / 3.0, 0.1, 100);
	myCam->setViewMatrixAsLookAt(
		osg::Vec3(-7.5, 7.5, 0), // eye above xy-plane
		sphereXForm->getPosition() + osg::Vec3(0, 3, 0),    // gaze at cycle
		osg::Vec3(0, 1, 0));   // usual up vector

	viewer.setCamera(myCam);
	viewer.setSceneData(root);
	int left = atoi(argv[1]);
	int right = atoi(argv[2]);
	int width = atoi(argv[3]);
	int height = atoi(argv[4]);
	viewer.setUpViewInWindow(left, right, width, height);
    viewer.realize();

    InputClient* ipc = new InputClient(&viewer, &gameLoop);
    ipc->run(); // Blocks until input ends (a player quits the game)
	delete ipc;
}
